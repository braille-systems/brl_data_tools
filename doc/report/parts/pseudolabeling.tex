\documentclass{main.tex}[subfiles]
\begin{document}
\section{Метод полуконтролируемого обучения с автоматическим исправлением ошибок}
% TODO describe why design is like this (? tell about IOvo's research, about my thoughts on recto/verso comparison, classic OCR)

Поскольку мы не ограничены в выборе текстов для создания набора данных, пусть это будут художественные произведения, электоронные варианты которых можно использовать для сравнения с результатом автоматической разметки.
Тогда процесс исправления неточностей будет заключаться в поиске сходства между распознанным текстом и оригиналом, и исправления в тех местах, где сходство нарушается.

\subsection{Предварительная обработка текста}

Исходные данные для алгоритма исправления ошибок -- текст, полученный в результате распознавания (символы азбуки Брайля, пробелы и переносы строк), а также первоначальный электронный текст (буквы в разном регистре, цифры и специальные символы).
% TODO describe grade 1

\subsection{Построение выравнивания}
Будем называть \emph{референсом (reference)} исходный текст и \emph{запросом (query)} строку, полученную в результате распознавания страницы (эти термины используются в биоинформатике, в задаче нахождения сходства между биологическими последовательностями).
Пусть эти две строки содержат только символы из некоторого алфавита $\mathcal A $. Введём символ \emph{пробела}: $ \ast \notin \mathcal A $.

\emph{Выравниванием} будем называть две строки одинаковой длины, полученные из референса и запроса вставкой нужного количества символов $\ast$ на некоторых позициях.
Выравнивание задаёт соответствие между символами двух строк с одинаковыми индексами (говорят, что символ из одной строки \emph{выравнивается} на другой); цель -- поиск наилучшего соответствия, содержащего как можно меньше пропусков и как можно больше попарных совпадений символов.

Ситуацию, когда два соответствующих символа в выравнивании различные и оба не являются пропусками, называют \emph{несовпадением (mismatch)}.
Если символ референса выравнивается на пропуск, это называют \emph{выпадением (deletion)}; выравнивание символа запроса на пробел -- \emph{вставка (insertion)}.
В нашей задаче, построив выравнивание, можно скорректировать метку класса в случае несовпадения или удалить метку в случае вставки.
Найденные выпадения никак не исправляются, поскольку мы не знаем, в каком месте изображения находится выпавший символ; в некоторых случаях можно попытаться определить место, где находится выпавшая буква, исходя из пространственного расположения соседних символов, но это выходит за рамки данной работы. \\

Похожие методы исправления символов ранее были разработаны для обычных программ распознавания текста по изображениям \cite{muller2021word_aln}.

\subsubsection{Поиск регионов интереса. Хэширование}

% TODO

\subsubsection{Оптимальное выравнивание. Алгоритм Нидлмана-Вунша}

Нидлман и Вунш \cite{needleman1970} разработали алгоритм, который находит оптимальное выравнивание, т. е. то, которое содержит наименьшее возможное число несовпадений.

Алгоритм работает так.
Пусть референс -- строка $r \in \mathcal{A}^m $, запрос $q \in \mathcal{A}^n$; с использованием динамического программирования строится матрица веса выравнивания $S_{n\times m}$ (в каждой ячейке $S_{ij}$ содержится вес оптимального выравнивания подстрок $q[0:i]$ и $r[0:j]$). % TODO describe what is r[0:j], q[0:i]
Выравнивание соответствует пути из левого верхнего угла такой матрицы в правый нижний; из каждой клетки $(i,j)$ возможны только переходы вправо (выпадение), вниз (вставка) или по диагонали вправо и вниз (совпадение / несовпадение в зависимости от того, одинаковые ли символы $r[i]$ и $r[j]$).
\begin{itemize}
    \item Сперва заполняется первая строка и первый столбец $S$: $S_{0j} = -j, \thickspace S_{i0} = -i$, т. е. выравниваниям $q[0:i]$ и  $r[0:j]$ на строку из пропусков присваивается отрицательный вес, который тем больше по модулю, чем больше пропусков.
    \item Затем заполняются все остальные клетки по правилу:
    \[ S_{ij} := \max \begin{cases}
        S_{i-1,j} - 1 \\
        S_{i,j-1} - 1 \\
        S_{i-1,j-1} + 1 \text{ \textbf{if} } q[i-1] = r[j-1] \text{ \textbf{else} } S_{i-1,j-1} - 1
    \end{cases} \]

    т. е. итоговый вес есть сумма вкладов всех выпадений, вставок и несовпадений ($-1$) и совпадений ($+1$).
    \item По построенной матрице $ S $ можно не только узнать вес оптимального выравнивания $S[n-1,m-1]$, но и найти само выравнивание, восстановив путь обратно из правой нижней клетки до левой верхней.

\end{itemize}

Наша задача такова, что референс обычно в полтора-два раза длиннее запроса и содержит участки в начале и конце, которые не должны соответствовать никаким участкам запроса.
В таких условиях алгоритм Нидлмана-Вунша может построить плохое выравнивание (с большими разрывами в запросе).
К примеру, взяв референс "homo homini lupus est"\hspace{0pt} и запрос "homoni lupus", получим оптимальное выравнивание

\begin{verbatim}
    homo homini lupus est
    hom***o**ni lupus****
\end{verbatim}

Немного модифицируем алгоритм: не будем штрафовать делеции до первого символа запроса и после последнего.
Для этого достаточно первую строку таблицы $ \{ S_{0j} \} $ инициализировать нулями, а в последней строке при добавлении делеции не вычитать единицу:

\[ S_{n,j} := \max \begin{cases}
    S_{n-1,j} - 1 \\
    S_{n,j-1} \\
    S_{n-1,j-1} + 1 \text{ \textbf{if} } q[i-1] = r[j-1] \text{ \textbf{else} } S_{n-1,j-1} - 1
\end{cases} \]

Такой алгоритм строит выравнивание с наименьшим возможным числом несовпадений на участке от первого отличного от пропуска символа запроса до последнего. % TODO оформить в виде теоремы
Теперь выравнивание выглядит так:

\begin{verbatim}
    homo homini lupus est
    *****homoni lupus****
\end{verbatim}

Ещё один, более компактный пример выравнивания ("caribbean"\hspace{0pt} и "bribe") визуализирован на рис. \ref{fig:caribbean_bribe}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\myPictWidth]{test_needleman_wunsch/caribbean_bribe}
    \caption{Матрица динамического программирования модифицированного алгоритма Нидлмана-Вунша для референса "caribbean"\hspace{0pt} и запроса "bribe". Жирными линиями обведены клетки, соотвтествующие найденному выравниванию }
    \label{fig:caribbean_bribe}
\end{figure}

На рис. \ref{fig:needleman_real} изображены тепловые карты, построенные для образца из реального набора данных. % TODO compare

\begin{figure}[H]
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=\myPictWidth]{test_needleman_wunsch/big_penalizeTrue}
        \caption{обычный алгоритм}
        \label{fig:needleman_real:usual}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=\myPictWidth]{test_needleman_wunsch/big_penalizeFalse}
        \caption{модифицированный алгоритм}
        \label{fig:needleman_real:modified}
    \end{subfigure}
    \caption{Тепловые карты матриц динамического программирования при выравнивании результата распознавания страницы из романа "Scarlet Letter"\hspace{0pt} на участок, найденный с помощью хэширования на референсе.
    Более светлые точки сооветствуют элементам матрицы с более высоким значением.}
    \label{fig:needleman_real} % TODO ref in the text
\end{figure}

\subsection{Исправление ошибок после выравнивания}
\end{document}